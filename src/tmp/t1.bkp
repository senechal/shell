#include<stdio.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<unistd.h>
#include<stdlib.h>
#include<string.h>

#define MAX_SIZE_IN 255
#define ABSOLUTE 1
#define RELATIVE 0
// Process functions

// Parser functions
void parse_entrada(char conteudo[], char *comando[], char **argumentos[], int *nro_argumentos){
    *nro_argumentos = 1;
    int i = 0,j = 0,l = 0, k = 0, s = 0;
    char temp[255];
    // estado = 0 -> comando ; estado = 1 -> argumentos
    int estado = 0;
    int tamanho = 0;
    j = strlen(conteudo);
    for (i = 0; i < j+1; i++) {
            if ((conteudo[i] == ' ') || (conteudo[i] == '\0')) {

                if (tamanho != 0 ) {
                    temp[l] = '\0';

                    if (estado == 0) {
                        *comando = (char *)malloc((tamanho+1)*(sizeof(char)));
                        (*argumentos) = (char**) malloc(sizeof(char*)*(*nro_argumentos));
                        strcpy(*comando,temp);
                        estado = 1;
                    }
                    else if (estado == 1) {
                        if (*nro_argumentos == 1) (*argumentos) = (char**) malloc(sizeof(char*));
                        *argumentos = (char**) realloc(*argumentos, sizeof(char*)*((*nro_argumentos)+1));
                        while (temp[k] != '\0') {
                            (*argumentos)[(*nro_argumentos)] = (char*) realloc((*argumentos)[(*nro_argumentos)], sizeof(char)*(s+1));
                            (*argumentos)[(*nro_argumentos)][s] = temp[k];
                            s++;
                            k++;
                        }
                        (*argumentos)[(*nro_argumentos)][s] = '\0';
                        (*nro_argumentos)++;
                        k = 0;
                        s = 0;

                    }
                    tamanho = 0;
                    l = 0;
                    estado = 1;
                    temp[0] = '\0';
                } else continue;
            }
            else {
                temp[l] = conteudo[i];
                tamanho = tamanho + 1;
                l++;
            }
    }
    (*argumentos) = (char**) realloc((*argumentos), sizeof(char*)*(*nro_argumentos+1));
    (*argumentos)[*nro_argumentos] = NULL;
}

//impressao
void print(int nro_argumentos, char **argumentos, char *comando){
    int i, s = 0;
    printf("%s\n",comando);  
    for (i = 1; i < (nro_argumentos); i++) {
        while (argumentos[i][s] != '\0') {
            printf("%c",argumentos[i][s]);
            s++;
        }
        s = 0;
    }
}

char * get_path(char *env[]){
    int i = 0, j;
    char tmp[5];
    char * path;
    while(env[i]!=NULL){
        strncpy(tmp, env[i], 4);
        tmp[4] = '\0';
        if(strcmp(tmp,"PATH") == 0){
            path = (char *) malloc(sizeof(char)*(strlen(env[i]) - 4));
            for(j = 5; j < strlen(env[i]); j++){
                path[j-5] = env[i][j];
            }
            path[strlen(env[i]) - 5] = '\0';
            return path;
        }
        i++;
    }
    return NULL;
}

char ** get_path_array(char *env[]){
    char * tmp = get_path(env);
//    char ** path_array = (char**) malloc(sizeof(char*));
    char ** path_array = NULL;
    char *aux = NULL;
    int i = 0, j = 0, size = 1;
    while(tmp[size-1] != '\0'){
        path_array = (char**) realloc(path_array, sizeof(char*)*(i+1));
        while(tmp[size-1] != ':' && tmp[size-1] != '\0'){
            aux = (char*) realloc(aux, sizeof(char)*(j+1));
            aux[j] = tmp[size-1];
            //path_array[i] = (char*) realloc(path_array[i], sizeof(char)*(j+1));
//            path_array[i][j] = tmp[size-1];
            j++;
            size++;
        }
        aux[j] = '\0';
        path_array[i] = (char*) malloc(sizeof(char)*(j+1));
        strcpy(path_array[i], aux);
        if(aux)
            free(aux);
        aux = NULL;
        j = 0;
        i++;
        if(tmp[size-1] == '\0')
            break;
        size++;
    }
    // adiciona-se uma posicao nula no vetor de strings para delimitar o fim
    path_array = (char**) realloc(path_array, sizeof(char*)*(i+1));
    path_array[i] = NULL;
    if(tmp){
        free(tmp);
        printf("free no tmp de boa\n");
    }
    return path_array;
}

int try_execute(char *comando, char ***argumentos, int nro_argumentos){
    // forks da vida..=P
    // trata localmente os argumentos: argv[0] deve ser igual ao comando
    // uso de uma funcao pra colocar o comando no argv[0]?
    printf("dentro do try_execute %s\n", comando);
    // copia o comando para o argumentos[0]
    strcpy((*argumentos)[0], comando);
    if (fork() == 0) {
        //processo filho
        execv(comando, (*argumentos));
    }
    else {
        //processo pai
        wait(NULL);
    }
    return 1;
}

int try_open(char *comando){
    FILE *a = fopen(comando, "r"); 
    if(a == NULL){
        return 0;
    }
    printf("%s\n", comando);
    fclose(a);  
    return 1;
}

int executa_comandos(char ***comandos, char ***argumentos, int nro_argumentos){
    int i = 0;
    int ret = 0;
    FILE *a; 
    while((*comandos)[i] != NULL){
//        if(try_open(comandos[i]))
        printf("tentando abrir %s\n", (*comandos)[i]);
        if((a = fopen((*comandos)[i], "r")) != NULL){
                fclose(a); 
                (*argumentos)[0] = (char*) malloc(sizeof(char)*(strlen((*comandos)[i])+1));
                strcpy((*argumentos)[0], (*comandos)[i]);
                printf("argumentos de zero =%s\n", (*argumentos)[0]);
                ret = try_execute((*comandos)[i], argumentos, nro_argumentos);
                if ((*argumentos)[0])
                    free((*argumentos)[0]); 
                break;
            }else{
                printf("nao conseguiu\n");
            }
        i++;
    }
    i = 0;
    while((*comandos)[i] != NULL){
        if((*comandos)[i])
            free((*comandos)[i]);
        i++;
    }
    if(*comandos)
        free(*comandos);
    i = 1;
    while((*argumentos)[i] != NULL){
        if((*argumentos)[i]) {
            free((*argumentos)[i]);
            printf("%d\n", i); 
        }
        printf("%d\n", i); 
        i++;
    }
    if(*argumentos)
        free(*argumentos);
    return ret;
}

char ** path_concat(char ***path_array, char *comando){
    int i = 0, size;
    char **new_path = NULL;
    while((*path_array)[i] != NULL){
        i++;
    }
    size = i;
    new_path = (char**) malloc(sizeof(char*)*(size+1));
    for(i = 0; i < size; i++){
        new_path[i] = (char *) malloc(sizeof(char)*(strlen((*path_array)[i])+strlen(comando)+2));
        strcpy(new_path[i], (*path_array)[i]);
        strcat(new_path[i], "/");
        strcat(new_path[i], comando);
    //    printf("%s\n", new_path[i]);
    }
    new_path[size] = NULL;
    for(i = 0; i < size; i++){
        if((*path_array)[i])
            free((*path_array)[i]);
    }
    if((*path_array))
        free((*path_array));
    return new_path;
}

// Retorna 1 se caminho eh absoluto e 0 se relativo
int verifica_caminho(char *comando){
    // por ora, verifica apenas se o primeiro carcater Ã© '/'
    if(comando[0] == '/')
        return ABSOLUTE; // absoluto
    return RELATIVE; // relativo
}

char **lista_comandos(char *comando, char *env[]){
    char **lista;
    char **path_array;
    if(verifica_caminho(comando) == ABSOLUTE){
        // absoluto retorna vetor com apenas um elemento
        lista = (char **) malloc(sizeof(char*)*2);
        lista[0] = (char*) malloc(sizeof(char)*strlen(comando));
        strcpy(lista[0], comando);
        lista[1] = NULL;
        return lista;
    }else{
        // relativo retorna todos os possiveis valores de acordo com o path
//        return path_concat(get_path_array(env), comando);
        path_array = get_path_array(env);
        lista = path_concat(&path_array, comando);
        return lista;
    }
}

//le entrada
int get_line(char **entrada) {
    char c; 
    int i = 0, saida = 255 ;
    (*entrada) = (char*) malloc(sizeof(char));
    saida = scanf("%c", &c); 
    while (c != '\n') {
        if (saida == EOF)
            return -1; 
        (*entrada) = (char*) realloc((*entrada), ++i);
        (*entrada)[i-1] = c; 
        saida = scanf("%c", &c); 
    }
    (*entrada) = (char*) realloc((*entrada), i+1); 
    (*entrada)[i] = '\0';
    return 1; 
}

int main(int argc, char *argv[], char *envp[]){
    char *comando, **argumentos, **comandos;
    int nro_argumentos;
    int i;
/*    size_t nbytes = 200;
    char *conteudo = (char*) malloc(nbytes); */
    char *conteudo;
    do{
        printf("A7> ");
        if(get_line(&conteudo) == -1)
            return 1;
/*        if(getline(&conteudo, &nbytes, stdin) == -1)
            break;
        conteudo[strlen(conteudo)-1] = '\0';*/
        parse_entrada(conteudo, &comando, &argumentos, &nro_argumentos);
//        print(nro_argumentos, argumentos, comando);
        comandos = lista_comandos(comando, envp);
        if(!executa_comandos(&comandos, &argumentos, nro_argumentos)){
            // trata erro de execucao
            printf("command not found\n"); 
        }
        if(comando)
            free(comando);
        if(conteudo)
            free(conteudo);
//        for(i = 0; i < nro_argumentos; i++){
//            printf("%s\n", argumentos[i]);
//            free(argumentos[i]);
//        }
//        if(argumentos)
//            free(argumentos);
    }while(1); 
    return 0;
}

